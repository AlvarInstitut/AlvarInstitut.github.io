<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="ca" xml:lang="ca" xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="stylesheet" type="text/css" href="base.css" />
<link rel="stylesheet" type="text/css" href="exe_highlighter.css" />
<link rel="stylesheet" type="text/css" href="content.css" />
<link rel="stylesheet" type="text/css" href="nav.css" />
<meta http-equiv="content-type" content="text/html;  charset=utf-8" />
<title>2.2.2.2 RD-Java: Accés a les dades | Bases de Dades </title>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<meta http-equiv="content-language" content="ca" />
<meta name="author" content="Àlvar Serrano Calduch" />
<meta name="generator" content="eXeLearning 2.7 - exelearning.net" />
<script type="text/javascript" src="exe_jquery.js"></script>
<script type="text/javascript" src="exe_highlighter.js"></script>
<script type="text/javascript" src="common_i18n.js"></script>
<script type="text/javascript" src="common.js"></script>
</head>
<body class="exe-web-site" id="exe-node-51"><script type="text/javascript">document.body.className+=" js"</script>
<div id="content">
<p id="skipNav"><a href="#main" class="sr-av">Omet navegació</a></p>
<div id="header" ><div id="headerContent">Bases de Dades</div></div>
<div id="siteNav">
<ul>
   <li><a href="index.html" class="daddy main-node">Tema 7: Bases de Dades NoSQL</a></li>
   <li><a href="1__introducci.html" class="no-ch">1 - Introducció</a></li>
   <li class="current-page-parent"><a href="2__firebase.html" class="current-page-parent daddy">2 - Firebase</a>
   <ul>
      <li><a href="21_creaci_duna_aplicaci.html" class="no-ch">2.1 Creació d'una aplicació</a></li>
      <li class="current-page-parent"><a href="22_realtime_database_rd.html" class="current-page-parent daddy">2.2 Realtime Database (RD)</a>
      <ul>
         <li><a href="221_rd_utilitzaci_des_de_lentorn_de_firebase.html" class="no-ch">2.2.1 RD: Utilització des de l'entorn de Firebase</a></li>
         <li class="current-page-parent"><a href="222_rd_utilitzaci_des_de_java.html" class="current-page-parent daddy">2.2.2 RD: Utilització des de Java</a>
         <ul>
            <li><a href="2221_rdjava_connexi_des_de_java.html" class="no-ch">2.2.2.1 RD-Java: Connexió des de Java</a></li>
            <li id="active"><a href="2222_rdjava_accs_a_les_dades.html" class="active no-ch">2.2.2.2 RD-Java: Accés a les dades</a></li>
            <li><a href="2223_rdjava_tot_lexemple.html" class="no-ch">2.2.2.3 RD-Java: Tot l'exemple</a></li>
         </ul>
         </li>
         <li><a href="223_rd_utilitzaci_des_dandroid.html" class="daddy">2.2.3 RD: Utilització des d'Android</a>
         <ul class="other-section">
            <li><a href="2231_rdandroid_connexi_des_dandroid.html" class="no-ch">2.2.3.1 RD-Android: Connexió des d'Android</a></li>
            <li><a href="2232_rdandroid_accs_a_les_dades.html" class="no-ch">2.2.3.2 RD-Android: Accés a les dades</a></li>
            <li><a href="2233_rdandroid_tot_lexemple.html" class="no-ch">2.2.3.3 RD-Android: Tot l'exemple</a></li>
         </ul>
         </li>
      </ul>
      </li>
      <li><a href="23_cloud_firestore_cf.html" class="daddy">2.3 Cloud Firestore (CF)</a>
      <ul class="other-section">
         <li><a href="231_cf_utilitzaci_des_de_lentorn_de_firebase.html" class="no-ch">2.3.1 CF: Utilització des de l'entorn de Firebase</a></li>
         <li><a href="232_cf_utilitzaci_des_de_java.html" class="daddy">2.3.2 CF: Utilització des de Java</a>
         <ul class="other-section">
            <li><a href="2321_cfjava_connexi_des_de_java.html" class="no-ch">2.3.2.1 CF-Java: Connexió des de Java</a></li>
            <li><a href="2322_cfjava_accs_a_les_dades.html" class="no-ch">2.3.2.2 CF-Java: Accés a les dades</a></li>
            <li><a href="2323_cfjava_tot_lexemple.html" class="no-ch">2.3.2.3 CF-Java: Tot l'exemple</a></li>
         </ul>
         </li>
         <li><a href="233_cf_utilitzaci_des_dandroid.html" class="daddy">2.3.3 CF: Utilització des d'Android</a>
         <ul class="other-section">
            <li><a href="2331_cfandroid_connexi.html" class="no-ch">2.3.3.1 CF-Android: Connexió</a></li>
            <li><a href="2332_cfandroid_accs_a_les_dades.html" class="no-ch">2.3.3.2 CF-Android: Accés a les dades</a></li>
            <li><a href="2333_cfandroid_tot_lexemple.html" class="no-ch">2.3.3.3 CF-Android: Tot l'exemple</a></li>
         </ul>
         </li>
      </ul>
      </li>
   </ul>
   </li>
   <li><a href="3__bases_de_dades_clauvalor.html" class="daddy">3 - Bases de Dades Clau-Valor</a>
   <ul class="other-section">
      <li><a href="31__installaci_de_redis.html" class="no-ch">3.1 - Instal·lació de Redis</a></li>
      <li><a href="32__utilitzaci_de_redis.html" class="daddy">3.2 - Utilització de Redis</a>
      <ul class="other-section">
         <li><a href="321__strings.html" class="no-ch">3.2.1 - Strings</a></li>
         <li><a href="322__keys.html" class="no-ch">3.2.2 - Keys</a></li>
         <li><a href="323__hash.html" class="no-ch">3.2.3 - Hash</a></li>
         <li><a href="324__list.html" class="no-ch">3.2.4 - List</a></li>
         <li><a href="325__set.html" class="no-ch">3.2.5 - Set</a></li>
         <li><a href="326__set_ordenat.html" class="no-ch">3.2.6 - Set ordenat</a></li>
      </ul>
      </li>
      <li><a href="33__connexi_des_de_java.html" class="no-ch">3.3 - Connexió des de Java</a></li>
   </ul>
   </li>
   <li><a href="4__mongodb.html" class="daddy">4 - MongoDB</a>
   <ul class="other-section">
      <li><a href="41__installaci_de_mongodb.html" class="no-ch">4.1 - Instal·lació de MongoDB</a></li>
      <li><a href="42__utilitzaci_de_mongodb.html" class="daddy">4.2 - Utilització de MongoDB</a>
      <ul class="other-section">
         <li><a href="421__tipus_de_dades.html" class="no-ch">4.2.1 - Tipus de dades</a></li>
         <li><a href="422__operacions_bsiques.html" class="no-ch">4.2.2 - Operacions bàsiques</a></li>
         <li><a href="423__operacions_dactualitzaci_avanada.html" class="daddy">4.2.3 - Operacions d'actualització avançada</a>
         <ul class="other-section">
            <li><a href="4231__set.html" class="no-ch">4.2.3.1 - $set</a></li>
            <li><a href="4232__unset.html" class="no-ch">4.2.3.2 - $unset</a></li>
            <li><a href="4233__rename.html" class="no-ch">4.2.3.3 - $rename</a></li>
            <li><a href="4234__inc.html" class="no-ch">4.2.3.4 - $inc</a></li>
            <li><a href="4235__elements_dun_array.html" class="no-ch">4.2.3.5 - Elements d'un array</a></li>
            <li><a href="4236__inserci_en_arrays_push.html" class="no-ch">4.2.3.6 - Inserció en Arrays: $push</a></li>
            <li><a href="4237__eliminaci_en_arrays_pop_i_pull.html" class="no-ch">4.2.3.7 - Eliminació en arrays: $pop i $pull</a></li>
            <li><a href="4238__upsert.html" class="no-ch">4.2.3.8 - Upsert</a></li>
         </ul>
         </li>
      </ul>
      </li>
      <li><a href="43__consulta_de_documents.html" class="daddy">4.3 - Consulta de documents</a>
      <ul class="other-section">
         <li><a href="431__parmetres_de_les_funcions_find_i_findone.html" class="no-ch">4.3.1 - Paràmetres de les funcions find() i findOne()</a></li>
         <li><a href="432__operadors_de_les_condicions.html" class="no-ch">4.3.2 - Operadors de les condicions</a></li>
         <li><a href="433__agregaci.html" class="no-ch">4.3.3 - Agregació</a></li>
      </ul>
      </li>
      <li><a href="44__connexi_des_de_java.html" class="no-ch">4.4 - Connexió des de Java</a></li>
   </ul>
   </li>
   <li><a href="exercicis.html" class="no-ch">Exercicis</a></li>
</ul>
</div>
<div id='topPagination'>
<div class="pagination noprt">
<a href="2221_rdjava_connexi_des_de_java.html" class="prev"><span><span>&laquo; </span>Anterior</span></a> <span class="sep">| </span><a href="2223_rdjava_tot_lexemple.html" class="next"><span>Següent<span> &raquo;</span></span></a>
</div>
</div>
<div id="main-wrapper">
<div id="main"><a name="main"></a>
<div id="nodeDecoration"><h1 id="nodeTitle">2.2.2.2 RD-Java: Accés a les dades</h1></div>
<div class="iDevice_wrapper textIdevice" id="id180">
<div class="iDevice emphasis0" >
<div id="ta180_185_2" class="block iDevice_content">
<div class="exe-text"><p class="titolet">Guardar dades</p>
<p>Disposem del mètode <strong>setValue()</strong> de la referència a la dada a la que volem accedir. Accepta 2 paràmetres:</p>
<ul>
<li>El primer és el valor que volem introduir.</li>
<li>El segon és un listener per a poder sincronitzar. Ens farà falta sincronitzar únicament en els programes mode text senzills que fem. Quan fem els gràfics no ens farà falta, i posarem <strong>null</strong></li>
</ul>
<p>Si per exemple vulguérem guardar en la variable <strong>a1</strong>, de forma senzilla ho faríem així (ens funcionaria en els gràfics):</p>
<pre style="background-color: #ffffff; color: #000000; font-family: 'DejaVu Sans Mono'; font-size: 9,0pt;"><span style="color: #660e7a;">refA1</span>.setValue(<span style="color: #660e7a;">"Valor per a a1"</span>, null);</pre>
<p>En l'operació de guardar si la parella clau-valor on es va a guardar existia, doncs modificarà el valor. I si no existia, la crearà.</p>
<p>En el cas que vulguem guardar no en l'arrel, sinó més avall en l'estructura JSON, disposem del mètode <strong>child()</strong>, que ens permet anar a un determinat fill, a l'estil de la segona manera descrita en el subpunt anterior. Per exemple si vulguérem canviar l'edat del primer empleat, l'estructura per a arribar seria:<strong> empresa --&gt; empleat --&gt; 0 --&gt; edat</strong></p>
<pre style="background-color: #ffffff; color: #000000; font-family: 'DejaVu Sans Mono'; font-size: 9,0pt;"><span style="background-color: #e4e4ff;">empresa</span>.child(<span style="color: #008000; font-weight: bold;">"empleat"</span>).child(<span style="color: #008000; font-weight: bold;">"0"</span>).child(<span style="color: #008000; font-weight: bold;">"edat"</span>).setValue(<span style="color: #008000; font-weight: bold;">"33"</span>, null);</pre>
<p>Si no existia abans qualsevol dels nodes de l'estructura, el crearà. Fins i tot, si no existira abans de la sentència anterior <strong>empresa</strong>, doncs crearia <strong>empresa</strong>, i dins d'ell <strong>empleat</strong>, i dins d'ell <strong>0</strong>, i dins d'ell <strong>edat</strong>, amb el valor 33.</p>
<p>També podríem guardar tot un objecte, i es convertirà en estructura JSON, però ens ho deixem per a més avant.</p>
<p>Però com havíem dit abans, s'ha de sincronitzar amb Firebase, des del programa Java ens hem d'esperar a aquesta sincronització, si no no ens funcionarà. En el segon paràmetre ens posem un <strong>listener</strong>. Aquest exemple ja està complet:</p>
<div class="highlighted-code language-java" style="font-weight: bold;">
<div>
<pre><code>import java.io.FileInputStream;
import java.io.IOException;
import java.util.concurrent.CountDownLatch;

import com.google.auth.oauth2.GoogleCredentials;
import com.google.firebase.FirebaseApp;
import com.google.firebase.FirebaseOptions;
import com.google.firebase.database.DatabaseError;
import com.google.firebase.database.DatabaseReference;
import com.google.firebase.database.FirebaseDatabase;

public class ProvaFirebaseGuardar {

	public static void main(String[] args) throws InterruptedException, IOException {
		FileInputStream serviceAccount = new FileInputStream("<strong>acces-a-dades-6e5a6-firebase-adminsdk-ei7uc-8f5d926921.json</strong>");

		FirebaseOptions options = new FirebaseOptions.Builder()
				.setCredentials(GoogleCredentials.fromStream(serviceAccount))
				.setDatabaseUrl("https://acces-a-dades-<strong>6e5a6</strong>.firebaseio.com").build();

		FirebaseApp.initializeApp(options);

		final DatabaseReference empresa = FirebaseDatabase.getInstance().getReference("empresa");

		CountDownLatch done = new CountDownLatch(1);
		empresa.child("empleat").child("0").child("edat").setValue("33", new DatabaseReference.CompletionListener() {
			@Override
			public void onComplete(DatabaseError de, DatabaseReference dr) {
				done.countDown();
			}
		});
		done.await();
	}
}
</code></pre>
</div>
</div>
<p>Recordeu que heu de canviar el <strong>nom del fitxer json</strong> i la <strong>URL</strong> per les vostres.</p>
<p>I aquest és el resultat d'executar-lo. A la dreta podem veure com s'està modificant la dada que preteníem:</p>
<p><img src="T7_2_3_3.1.png" alt="" width="1440" height="900" /></p>
<p>Però com comentàvem, en el cas de les aplicacions gràfiques resulta més senzill, ja que no haurem d'esperar expressament a la sincronització, sinó que l'aplicació es queda en marxa, i per tant no hi haurà problema.</p>
<p>Ho practicarem en un exemple nou, on arribarem a construir un Xat, i ens servirà per a practicar totes les coses que us volem mostrar en Realtme Database de Firebase.</p>
<p>Aquest és l'esquelet del programa:</p>
<div class="highlighted-code language-java" style="font-weight: bold;">
<div>
<pre><code>import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.FileInputStream;
import java.io.IOException;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JTextField;

import com.google.auth.oauth2.GoogleCredentials;
import com.google.firebase.FirebaseApp;
import com.google.firebase.FirebaseOptions;
import com.google.firebase.database.ChildEventListener;
import com.google.firebase.database.DataSnapshot;
import com.google.firebase.database.DatabaseError;
import com.google.firebase.database.DatabaseReference;
import com.google.firebase.database.FirebaseDatabase;
import com.google.firebase.database.ValueEventListener;

public class Pantalla_CrearXat extends JFrame implements ActionListener {

	private static final long serialVersionUID = 1L;
	JLabel etUltimMissatge= new JLabel("Últim missatge: ");
	JLabel ultimMissatge= new JLabel();
	
	JLabel etiqueta = new JLabel("Missatges:");
	JTextArea area = new JTextArea();

	JLabel etIntroduccioMissatge = new JLabel("Introdueix missatge:");
	JButton enviar = new JButton("Enviar");
	JTextField missatge = new JTextField(15);

	// en iniciar posem un contenidor per als elements anteriors
	public void iniciar() throws IOException {
		JFrame pantPrincipal = this;
		this.setBounds(100, 100, 450, 300);
		this.setLayout(new BorderLayout());
		// contenidor per als elements
		//Hi haurà títol. Panell de dalt: últim missatge. Panell de baix: per a introduir missatge. Panell central: tot el xat
		
		JPanel panell1 = new JPanel(new FlowLayout());
		panell1.add(etUltimMissatge);
		panell1.add(ultimMissatge);
		getContentPane().add(panell1, BorderLayout.NORTH);

		JPanel panell2 = new JPanel(new BorderLayout());
		panell2.add(etiqueta, BorderLayout.NORTH);
		area.setForeground(Color.blue);
		JScrollPane scroll = new JScrollPane(area);
		panell2.add(scroll, BorderLayout.CENTER);
		getContentPane().add(panell2, BorderLayout.CENTER);
		
		JPanel panell3 = new JPanel(new FlowLayout());
		panell3.add(etIntroduccioMissatge);
		panell3.add(missatge);
		panell3.add(enviar);
		getContentPane().add(panell3, BorderLayout.SOUTH);

		setVisible(true);
		enviar.addActionListener(this);

		FileInputStream serviceAccount = new FileInputStream("acces-a-dades-6e5a6-firebase-adminsdk-ei7uc-8f5d926921.json");

		FirebaseOptions options = new FirebaseOptions.Builder()
				.setCredentials(GoogleCredentials.fromStream(serviceAccount))
				.setDatabaseUrl("https://acces-a-dades-6e5a6.firebaseio.com").build();

		FirebaseApp.initializeApp(options);

		// Exemple de listener de lectura única addListenerForSingleValue()
		// Per a posar el títol. Sobre nomXat
		
		// Exemple de listener de lectura contínua addValueEventListener()
		// Per a posar l'últim missatge registrat. Sobre a1
		
		// Exemple de listener d'una llista addChildEventListener()
		// Per a posar tota la llista de missatges. Sobre xat

	}

	@Override


public void actionPerformed(ActionEvent e) {
		if (e.getSource() == enviar) {
			// Exemple de guardar dades sense haver d'esperar per ser una aplicació gràfica
			// Per a guardar dades. Sobre a1, i despŕes sobre la llista xat
<br />		}
	}

}</code></pre>
</div>
</div>
<div id="ta164_85" class="block iDevice_content">
<p>Recordeu que heu de canviar el <strong>nom del fitxer json</strong> i la <strong>URL</strong> per les vostres. Ho podeu copiar de l'exemple anterior</p>
<p>I aquest és el programa principal:</p>
<div class="highlighted-code language-java" style="font-weight: bold;">
<div>
<pre><code>import java.io.IOException;

public class CrearXat {

    public static void main(String[] args) throws IOException {
        final Pantalla_CrearXat finestra = new Pantalla_CrearXat();
        finestra.iniciar();
    }
}</code></pre>
</div>
</div>
<p>Observeu que ja tenim col·locades en l'anterior programa les dades de connexió:</p>
<div class="highlighted-code language-java" style="font-weight: bold;">
<div>
<pre><code>		FileInputStream serviceAccount = new FileInputStream("acces-a-dades-6e5a6-firebase-adminsdk-ei7uc-8f5d926921.json");

		FirebaseOptions options = new FirebaseOptions.Builder()
				.setCredentials(GoogleCredentials.fromStream(serviceAccount))
				.setDatabaseUrl("https://acces-a-dades-6e5a6.firebaseio.com").build();

		FirebaseApp.initializeApp(options);
</code></pre>
</div>
</div>
<p>I torne a insistir en què heu de <strong>canviar la referència al fitxer JSON i la URL</strong>.</p>
<p></p>
<p>Per a guardar les dades, en aquest exemple de moment guardarem en la clau de Firebase <strong>a1</strong> en el moment de apretar el botó de baix d'<strong>Enviar</strong>. No farà falta muntar cap listener per veure si ja hem acabat, ja que el programa continua en marxa.</p>
<div class="highlighted-code language-java" style="font-weight: bold;">
<div>
<pre><code>public void actionPerformed(ActionEvent e) {
		if (e.getSource() == enviar) {
			// Exemple de guardar dades sense haver d'esperar per ser una aplicació gràfica
			// Per a guardar dades. Sobre a1, i despŕes sobre la llista xat
			final DatabaseReference refA1 = FirebaseDatabase.getInstance().getReference("a1");
			refA1.setValue(missatge.getText(), null);
		}
	}
}</code></pre>
</div>
</div>
<p>Observeu que ara queda molt senzilla la sentència de guardar, i no ha fet falta ficar cap listener en el segon paràmetre, sinó <strong>null</strong>, per estar en una aplicació gràfica:</p>
<div class="highlighted-code language-java" style="font-weight: bold;">
<div>
<pre><code><strong>refA1.setValue(missatge.getText(), null);</strong></code></pre>
</div>
</div>
<p>El resultat seria aquest, on es veu la modificació de la dada que volíem:</p>
<p style="text-align: center;"><img src="T7_2_2_2_2_2.png" alt="" width="1329" height="738" /></p>
<p></p>
<p style="text-align: center;"></p>
</div></div>
</div>
</div>
</div>
<div class="iDevice_wrapper textIdevice" id="id185">
<div class="iDevice emphasis0" >
<div id="ta185_187_2" class="block iDevice_content">
<div class="exe-text"><p class="titolet">Recuperar dades</p>
<p>La lectura de dades és més complicada que l'escriptura. És en bona part per culpa de la "sincronització" de les dades que obtenim. Per això no existeix un mètode tan senzill com el <span style="color: #ff0000;"><strong>getValue()</strong></span>. La lectura s'ha de muntar sempre amb <strong> Listeners</strong>, que es queden escoltant si hi ha alguna actualització de la dada registrada. Recordeu que és de la dada registrada, no de tota la Base de Dades.</p>
<p>Podem muntar dos tipus de Listeners, però el seu funcionament serà similar</p>
<ul>
<li>Els que només escolten per a llegir les dades al principi, i no esperaran per a posteriors canvis en les dades (i per tant no consumiran tants recursos): <strong>addListenerForSingleValueEvent()</strong></li>
<li>Els que es queden escoltant tota l'estona: <strong>addValueEventListener()</strong><strong></strong></li>
</ul>
<p>En ambdos casos obtenim com a paràmetre un <strong>Data</strong><strong>Snapshot</strong> (còpia) de la dada registrada. I d'aquest tipus, <strong>DataSnapshot</strong>, sí que tenim el mètode <strong>getValue()</strong> per a accedir a la dada. Ambdós tipus de Listeners tenen un tractament absolutament similar, únicament amb la diferència abans esmentada que el segon està sempre escoltant, i el primer només escolta una vegada al principi.</p>
<p>El mètode <strong>getValue()</strong> admet un paràmetre que serà la classe del tipus que volem obtenir. Podem posar les següents:</p>
<ul>
<li><strong>String.class</strong>, i aleshores el que obtenim s'interpretarà com un String</li>
<li><strong>Double.class</strong>, i s'interpretarà com un número real de doble precisió</li>
<li><strong>Boolean.class</strong>, i s'interptretaràcom un valor booleà</li>
<li>També es poden posar classes per a obtenir tot un objecte (Map) i per a una llista (List). Fins i tot es podria arribar a posar una classe definida per nosaltres. Però amb els anteriors nosaltres en tindrem prou</li>
</ul>
<p></p>
<h2>addListenerForSingleValue()</h2>
<p>En aquest primer exemple anem a agafar una única vegada la dada que ens interessa, i per tant  utilitzarem <strong>addListenerForSingleValueEvent()</strong>. Ens servirà per a posar el títol de l'aplicació, i ho farem consultant la clau <strong>nomXat </strong>que haurà d'estar creada prèviament des del mateix entorn de Firebase.</p>
<p><img src="T7_2_2_2_2_3.png" alt="" style="display: block; margin-left: auto; margin-right: auto;" width="1328" height="737" /></p>
<pre style="background-color: #ffffff; color: #000000; font-family: 'DejaVu Sans Mono'; font-size: 9,0pt;"></pre>
<p>Modificarem el fragment de programa marcat pel comentari, i el que fem és esperar per a llegir només una vegada.<strong></strong></p>
<div class="highlighted-code language-java" style="font-weight: bold;">
<div>
<pre><code>		// Exemple de listener de lectura única addListenerForSingleValue()
		// Per a posar el títol. Sobre nomXat
		final DatabaseReference nomXat = FirebaseDatabase.getInstance().getReference("nomXat");

		nomXat.addListenerForSingleValueEvent(new ValueEventListener() {
			@Override
			public void onDataChange(DataSnapshot dataSnapshot) {
				pantPrincipal.setTitle(dataSnapshot.getValue(String.class));
			}

			@Override
			public void onCancelled(DatabaseError error) {
			}
		});
</code></pre>
</div>
</div>
<p>Aquest és el resultat, i quan l'executeu observareu que tarda un poc en mostrar el títol. És perquè ho està llegint de Firebase.</p>
<p><img src="T7_2_2_2_2_4.png" alt="" style="display: block; margin-left: auto; margin-right: auto;" width="450" height="300" /></p>
<p></p>
<h2>addValueEventListener()</h2>
<p>Anem a veure ara un exemple per a l'altre mètode, el <strong>addValueEventListener()</strong>, que és el que es queda escoltant tota la estona</p>
<p>Concretarem el que farem és escoltar  tota la estona per si es produeix algun canvi en la clau <strong>a1</strong>. Si es produeix aquest canvi, modificarà el valor del JLabel <strong>ultimMissatge </strong>que està dalt.</p>
<p>També afegirem el missatge al JTextArea, per a que tinga apariència de xat, encara que després ho modificarem per a millorar-ho. Ho hem de col·locar on està marcat pel comentari</p>
<div class="highlighted-code language-java" style="font-weight: bold;">
<div>
<pre><code>		// Exemple de listener de lectura contínua addValueEventListener()
		// Per a posar l'últim missatge registrat. Sobre a1
		final DatabaseReference ultim = FirebaseDatabase.getInstance().getReference("a1");

		ultim.addValueEventListener(new ValueEventListener() {
			@Override
			public void onDataChange(DataSnapshot dataSnapshot) {
				ultimMissatge.setText(dataSnapshot.getValue(String.class));
				area.append(dataSnapshot.getValue(String.class) + "\n");  // aquesta línia després la llevarem
			}

			@Override
			public void onCancelled(DatabaseError error) {
			}
		});
</code></pre>
</div>
</div>
<p><br /><code></code></p>
<p>L'execució serà com la de la pantalla de dalt a l'esquerra. Però si es produeix algun canvi (com es mostra en la pantalla de la dreta), aquest canvi es reflectirà automàticament tant en el JLabel de dalt com en el TextArea, tal i com es mostra en la imatge de baix a l'esquerra:</p>
<table style="width: 100%;">
<tbody>
<tr>
<td>
<p><img src="T7_2_2_2_2_6.png" alt="" width="450" height="300" /></p>
<p><img src="T7_2_2_2_2_8.png" alt="" width="450" height="300" /></p>
</td>
<td><img src="T7_2_2_2_2_7.png" alt="" width="1319" height="733" /></td>
</tr>
</tbody>
</table>
<p></p>
<p>Com veieu ha estat molt fàcil construir una espècie de xat. Ara millorarem aquest xat.</p>
<p>Això sí, una vegada està en marxa el programeta del xat, per més que canviem <strong>nomXat</strong>, que es traslladava al títol de la finestra, aquest títol ja <strong>no canviarà</strong> perquè recordem que es feia una única lectura</p>
<p style="text-align: center;"><img src="T7_2_2_2_2_8_5.png" alt="" width="1025" height="800" /></p>
<p style="text-align: center;"></p>
<p></p>
<p></p>
<p style="text-align: center;"></p></div>
</div>
</div>
</div>
<div class="iDevice_wrapper textIdevice" id="id186">
<div class="iDevice emphasis0" >
<div id="ta186_187_2" class="block iDevice_content">
<div class="exe-text"><p class="titolet">Tractament de llistes</p>
<p>Per a explicar millor el tractament de llistes, crearem una altra referència a una clau que representarà una llista de missatges. Cada missatge constarà d'un nom i un contingut, i així vuerem també el tractament d'objectes.</p>
<p>El primer que ens haurem de definir és la referència a aquesta nova clau, que l'anomenarem <strong>xat</strong> (no està creada encara en la Base de Dades).</p>
<pre style="background-color: #ffffff; color: #000000; font-family: 'DejaVu Sans Mono'; font-size: 9,0pt;"><span style="color: #000080; font-weight: bold;">final </span>DatabaseReference xat = FirebaseDatabase.getInstance().getReference(<span style="color: #008000; font-weight: bold;">"xat"</span>);</pre>
<p>Anar afegint elements a la llista, ho podem fer a mà, posant nosaltres l'índex, ja que hem vist que la manera de representar en Firebase una llista són fills únicament amb clau, que seria el subíndex.</p>
<p>Per tant una manera d'afegir el primer missatge del xat, seria amb l'índex 0. Posem aquest codi quan apretem el botó (no hem llevat de moment el fet de guardar en <strong>a1</strong>, per a que mentre fem les proves es veja tot el xat):</p>
<div class="highlighted-code language-java" style="font-weight: bold;">
<div>
<pre><code>        public void actionPerformed(ActionEvent e) {
		if (e.getSource() == enviar) {
			// Exemple de guardar dades sense haver d'esperar per ser una aplicació gràfica
			// Per a guardar dades. Sobre a1, i despŕes sobre la llista xat
			final DatabaseReference refA1 = FirebaseDatabase.getInstance().getReference("a1");
			refA1.setValue(missatge.getText(), null);
			final DatabaseReference xat = FirebaseDatabase.getInstance().getReference("xat"); 
			xat.child("0").child("nom").setValue("Usuari1",null); 
			xat.child("0").child("contingut").setValue(missatge.getText(),null);
		}
	}</code></pre>
</div>
</div>
<p>Quan apretem s'actualitzarà la Base de Dades d'aquesta manera:</p>
<p style="text-align: center;"><img src="T7_2_2_2_2_9.png" alt="" width="587" height="377" /></p>
<p>Però aquesta manera d'introduir en la llista acaba per ser molt poc pràctica. Si ara anàrem a introduir un segon missatge (nom i contingut) li hauríem de posar com a índex 1. No és viable.</p>
<p>Podríem dur 2 polítiques per a gestionar els índex:</p>
<ul>
<li>Podríem portar un comptador per a saber quin índex toca inserir en cada moment, cosa també molt poc pràctica perquè si l'aplicació està instal·lada en més d'un dispositiu, podria haver col·lisió en el número d'índex.</li>
<li>Podríem mirar quin és l'últim índex introduït, per a incrementar-lo en una unitat. Però açò suposa llegir de la Base de Dades, i com hem vist abans suposarà muntar un Listener, segurament dels d'un únic ús. Per tant se'ns complic la cosa. Es pot fer, però no és còmode.</li>
</ul>
<p>Per a estalviar-nos aquesta feina, Firebase ens proporciona un métode per a afegir un nou element a una llista, el mètode <strong>push()</strong>. Introdueix un nou element a la llista, i li posa com a índex un numero generat de manera que no es repetirà mai. L'única preocupació que hem de tenir és guardar aquest índex (amb <strong>getKey()</strong>), per a poder posar-lo com a clau.</p>
<div class="highlighted-code language-java" style="font-weight: bold;">
<div>
<pre><code>	public void actionPerformed(ActionEvent e) {
		if (e.getSource() == enviar) {
			// Exemple de guardar dades sense haver d'esperar per ser una aplicació gràfica
			// Per a guardar dades. Sobre a1, i despŕes sobre la llista xat
			final DatabaseReference refA1 = FirebaseDatabase.getInstance().getReference("a1");
			refA1.setValue(missatge.getText(), null);
			final DatabaseReference xat = FirebaseDatabase.getInstance().getReference("xat");
			String clau = xat.push().getKey(); 
			xat.child(clau).child("nom").setValue("Usuari1",null); 
			xat.child(clau).child("contingut").setValue(missatge.getText(),null);
		}
	}
</code></pre>
</div>
</div>
<p>I el resultat és aquest:</p>
<p style="text-align: center;"><img src="T7_2_2_2_2_10.png" alt="" width="552" height="441" /></p>
<p>Com veiem és una cadena molt llarga que no és repetirà mai.</p>
<p>Anem a fer una tercera inserció d'un missatge, però ara ho completarem més, i solucionarem de pas algun problemeta que podíem haver tingut.</p>
<p>Crearem una classe anomenada <strong>Missatge</strong>, que inclourà les propietats <strong>nom</strong> i <strong>contingut</strong>. Crearem un objecte <strong>Missatge </strong>amb uns nous valors, i veurem que el podem guardar perfectament. Per a aquest exemple segurament no valdria la pena l'esforç, però es pot veure la utilitat per a objectes més complexos.</p>
<p>Primer definim la classe. El millor és que el guardem com una classe nova, és a dir com a <strong>Missatge.java </strong><strong></strong>:</p>
<pre style="background-color: #ffffff; color: #000000; font-family: 'DejaVu Sans Mono'; font-size: 9,0pt;"><span style="color: #000080; font-weight: bold;">public class </span>Missatge{<br />    <span style="color: #000080; font-weight: bold;">public </span>String <span style="color: #660e7a; font-weight: bold;">nom</span>;<br />    <span style="color: #000080; font-weight: bold;">public </span>String <span style="color: #660e7a; font-weight: bold;">contingut</span>;<br /><br />    <span style="color: #000080; font-weight: bold;">public </span>Missatge(){<br />    }<br /><br />    <span style="color: #000080; font-weight: bold;">public </span>Missatge(String nom,String cont){<br />        <span style="color: #000080; font-weight: bold;">this</span>.<span style="color: #660e7a; font-weight: bold;">nom</span>=nom;<br />        <span style="color: #000080; font-weight: bold;">this</span>.<span style="color: #660e7a; font-weight: bold;">contingut</span>=cont;<br />    }<br />}</pre>
<p>Millor tenir també els <strong>getters</strong> i <strong>setters</strong>.</p>
<p>Per a guardar, col·locaríem aquestes sentències entre les accions del clic del botó, com en les altres ocasions. Observeu com ara ni tan sols ens fa falta guardar en una variable el <strong>getKey()</strong>, ja que es fa tot només en una operació:</p>
<div class="highlighted-code language-java" style="font-weight: bold;">
<div>
<pre><code>public void actionPerformed(ActionEvent e) {
		if (e.getSource() == enviar) {
			final DatabaseReference refA1 = FirebaseDatabase.getInstance().getReference("a1");
			refA1.setValue(missatge.getText(), null);
			final DatabaseReference xat = FirebaseDatabase.getInstance().getReference("xat");
			Missatge m = new Missatge("Usuari1",missatge.getText());
			xat.push().setValue(m,null);
		}
	}</code></pre>
</div>
</div>
<p>El resultat seria el mateix que en l'ocasió anterior:</p>
<p style="text-align: center;"><img src="T7_2_2_2_2_11.png" alt="" width="604" height="525" /></p>
<p>Ara només ens falta el tractament de lectura de les llistes.</p>
<h2>addChildEventListener()</h2>
<p>Podríem muntar un Listener com en les altres ocasions, però ara disposarem d'uns altres Listeners que se'ns acoplen millor ja que s'activen quan hi ha modificacions en algun element de la llista. En l'exemple només utilitzarem el de creació d'un nou element, però com veurem també podríem utilitzar els moments de supressió o modificació d'elements.</p>
<p>Es tracta del Listener <strong>ChildEventListener</strong>, i hem d'utilitzar el mètode <strong>addChildEventListener()</strong> sobre la llista. Voldrà la implementació dels mètodes: <strong>onChildAdded()</strong>, <strong>onChildChanged()</strong>, <strong>onChildRemoved()</strong> i <strong>onChildMoved()</strong>. Però com comentàvem ara només utilitzarem la de creació d'un nou element, i senzillament el mostrarem en el TextView.</p>
<p>Al <strong>dataSnapshot</strong> arriba únicament l'element introduït, modificat o esborrat, no tota la llista. Per tant és molt còmode. També arriba una referència a l'element anterior com a segon paràmetre, per si hem de fer algun tractament. Açò ens substituirà l'escriptura que féiem abans del TextArea (a mi m'havia quedat en la línia 101). Per tant llevem aquesta línia:</p>
<div style="font-weight: bold;">
<div>
<pre><span style="color: #ff0000;"><code>				area.append(dataSnapshot.getValue(String.class) + "\n");  // aquesta línia després la llevarem</code></span></pre>
</div>
</div>
<p>I posem el següent on queda marcat pel comentari.Així ens quedarà un xat més "professional"</p>
<div class="highlighted-code language-java" style="font-weight: bold;">
<div>
<pre><code>		// Exemple de listener d'una llista addChildEventListener()
		// Per a posar tota la llista de missatges. Sobre xat
		final DatabaseReference xat = FirebaseDatabase.getInstance().getReference("xat");

		xat.addChildEventListener(new ChildEventListener() {
			@Override
			public void onChildAdded(DataSnapshot dataSnapshot, String s) {
				area.append(dataSnapshot.child("nom").getValue(String.class) + ": "
						+ dataSnapshot.child("contingut").getValue(String.class) + "\n");
			}

			@Override
			public void onChildChanged(DataSnapshot dataSnapshot, String s) {
			}

			@Override
			public void onChildRemoved(DataSnapshot dataSnapshot) {
			}

			@Override
			public void onChildMoved(DataSnapshot dataSnapshot, String s) {
			}

			@Override
			public void onCancelled(DatabaseError databaseError) {
			}
		});
</code></pre>
</div>
</div>
<p><br /><code><br /></code></p>
<p>Si executem aquest programa, tenint només en el clic del botó l'addició d'un element a la llista i aquest Listener anterior, veurem que inicialment ens apareixeran tots els elements de la llista. Això és perquè considera que inicialment s'afegeix cadascun dels elements de la llista, i en el mateix ordre en que estan definits. En aquest imatge hem aprofitat per afegir un quart missatge:</p>
<p style="text-align: center;"><img src="T7_2_2_2_2_12.png" alt="" width="450" height="300" /></p></div>
</div>
</div>
</div>
<div id='bottomPagination'>
<div class="pagination noprt">
<a href="2221_rdjava_connexi_des_de_java.html" class="prev"><span><span>&laquo; </span>Anterior</span></a> <span class="sep">| </span><a href="2223_rdjava_tot_lexemple.html" class="next"><span>Següent<span> &raquo;</span></span></a>
</div>
</div>
</div>
</div>
</div>
</body></html>